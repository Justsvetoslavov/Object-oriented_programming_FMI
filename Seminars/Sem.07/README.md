# **Предефиниране на оператори. Приятелски класове и функции.**

Предефинирането на оператори ни позволява да дефинираме поведение на оператор, който се прилага върху операнда(и) от даден тип. <br />
Те са функции със специални имена: ключовата дума **operator** последвана от символа на респективния оператор (например **operator=**). Както всяка функция, те имат return type, лист от параметри и тяло. <br />

## [Oператори](https://en.cppreference.com/w/cpp/language/operators)
### **Видове оператори:**
в C++ има два вида оператори:
 - **Унарни** (на един аргумент)
 - **Бинарни** (на два аргумента)

### **Операторите се характеризират с:**
 - Приоритет 
 - Асоциативност
 - Тернарен 

При бинарните лявата операнда се подава като първи параметър, а втората - като втори. С изключение на function call оператора **operator()**, всички предефинирани оператори приемат параметри. <br />  
Ако един предефиниран параметър бива дефиниран като член-функция на класа, то лявата операнда бива директно асоциирана с обекта, върху който се извиква функцията, т.е. с **this**, като в този случай оператора има с един по-малко параметри. <br />
```
Можем да предефинираме единствено съществуващи вече оператори и не можем да създаваме нови "операторни" символи!
```  
Четирите символа (+,-,* и &) служат както за унарни, така и за бинарни оператори. Всеки от тях може да бъде предефиниран, като бройката параметри определя кой оператор влиза в употреба. <br />
### Операторите се характеризират с:
 -  Приоритет - при изрази с повече от един на брой оператора, определят последователността, в която ще бъдат извършени операциите; 
 -  Асоциативност - при изрази с оператори от еднакъв порядък, аналогично дефинират последователността, в която ще бъдат извършени операциите;
 -  Позиция на оператора спярмо аргумента - *префиксен*, *инфиксен* и *суфиксен*

 ### Пример
```
Разглеждаме израза a~b~c~d~f. Нека бинарната операция ~ е:
- ляво асоциативна. Тогава израза приема вида (((a~b)~c)~d)~f)
- дясно асоциативна. Тогава израза приема вида (a~(b~(c~(d~f))))
```

При предефинирането на оператор **не могат** да се променят *приоритета*, *асоциативността*, броят и позицията на *аргументите* му.

### **Списъка на операторите в C++:**
| Оператор                                       | Асоциативност                   |
|------------------------------------------------|---------------------------------|
| () [] -> . ++ - -                              |         лявоасоциативен         |
|  + - ! ~ ++ - - (type)* & sizeof               |         дясноасоциативен        |
| * / %                                          |         лявоасоциативен         |
|  + -        									 |         лявоасоциативен         |
|    << >>      								 |         лявоасоциативен         |
|  <  <=  >  >=         						 |         лявоасоциативен         |
|    ==  !=       								 |         лявоасоциативен         |
|      &     									 |         лявоасоциативен         |
|     ^      									 |         лявоасоциативен         |
|      \|     									 |         лявоасоциативен         |
|       &&    									 |         лявоасоциативен         |
|      \|\|     								 |         лявоасоциативен         |
|      ?:    									 |         дясноасоциативен        |
|     =  +=  -=  *=  /=  %=  >>=  <<=  &=  ^=    |         дясноасоциативен        |

- Пример - предефиниране на оператор

_В допълнение погледнете https://en.cppreference.com/w/cpp/language/operator_precedence  - тук са описани операторите в C++, не всички от които могат да бъдат предефинирани обаче!_  

При дизайн на клас: 
- Ако се извършва IO върху класа, то се дефинират shift операторите **<<** и **>>**;
- Ако класът изисква проверка за равенство, то се дефинира оператора **==**. Ако е дефиниран операторът **==**, то най-вероятно трябва да се дефинира и оператора **!=**;
- Ако класът притежава някакъв вид наредба, то се дефинира оператора **<**. При наличието на дефиниран този оператор, то трябва и да се дефинират всички останали релационни оператори;
- return type-a на един предефиниран оператор трябва да бъде съвместим с return-a на вградените (built in) оператори. Логическите и релационните оператори връщат **bool**, аритметичните - стойност от същия тип (нова, т.е. не връщаме референция), а при операторите за присвояване (```*=,  /=, +=, -=``` и т.н.) връщат референция към лявата операнда (lhs) в операцията.

```c++
Complex& Complex::operator+=(const Complex& other) {
	real += other.real;
	im += other.im;
	return *this;
}

int main() {
	Complex c(1,3); //1 + 3i;
	Complex c2(10,20) // 10 + 2i;
	c += c2 // now c is 11 + 5i
}
```
При предефинирането на оператор **не могат** да се променят **приоритетa**, **асоциативността**, броят и позицията на **аргументите** му.

### Въпрос: Кога дефинираме един оператор като член-функция?  
При предефиниране на оператори трябва да решим - да се дефинира ли като член-функция или не. В някои случаи нямаме избор, в други няма да успеем да дефинираме оператора подходящо, ако е дефиниран като член-функция.    
Следните "правила" могат да се следват като насока при решаване на този проблем:
- Присвояващия (**=**), индексния (**[]** - за достъпване на елемент, предимно при контейнери), function-call (**()**) и member access (**->** - за достъпване на елементи, при итератори и smart pointer-и) **трябва** да бъдат дефинирани като членове;
- Съставните присвояващи оператори обикновено **трябва** да бъдат дефинирани като членове. За разлика от **=** обаче, те не са задължени да бъдат такива;
- Оператори, които променят състоянието на техния обект (такива като операторите за инкрементиране, декрементиране и дереференциране) обикновено се дефинират като членове;
- Симетричните оператори - тези, които могат да преобразуват коя-да е от операндите, напр. аритметичните, релационните, побитовите - обикновено се дефинират извън класа;

![image](https://user-images.githubusercontent.com/49128895/229921765-9662c062-a990-4be0-9513-59bbf3ea095a.png)

## [Приятелски класове и приятелски функции](https://en.cppreference.com/w/cpp/language/friend)
Декларират се със запазената дума **friend** пред прототипа на функцията.  
Даденият friend-клас/функция има достъп до всички компоненти на класа. 
Т.е. всички членове на класа са public за friend-класовете/функциите приятели.

Приятелски класове/функции:
- Не се наследяват
- Не са транзитивни (приятелски клас на ваш приятелски клас, не е приятелски клас на вас)
- Може да се напишат в private, protected, public частта на class-a (Добрата практика е само в public)

 ```c++
class Complex {
private:
	double real;
	double im;
public:
	friend complex operator*(const Complex&, double);
	friend complex operator*(double, const Complex&);
	.
	.
	.
}
 ```
 
  ```c++
Complex operator*(const Complex& obj, double scalar) {
	 complex temp(obj);
	 temp.real *= scalar;
	 temp.im *= scalar;
	
	 return temp;
}
//since the multiplication is commutative we can use the previous function in the definition of the next one
Complex operator*(double scalar, const Complex& obj) {
	 return (obj * scalar);
}
```

### Оператори за вход/изход от/към поток
Както знаем вече, IO библиотеката използва shift операторите **>>** и **<<** за вход и изход от/към поток. Тя сама дефинира версии на тези оператори за четене и писане на вградени типове. 
### Предефиниране на operator<< и operator>>
```c++
class Complex{
    	double real;
    	double im;
public:
	friend std::ostream& operator<<(std::ostream&, const Complex&);
	friend std::istream& operator>>(std::istream& is, Complex& r);
}

std::ostream& operator<<(std::ostream& os, const Complex& r) {
	return os << r.real << "+" << r.im << "i";
}
std::istream& operator>>(std::istream& is, Complex& r) {
	return is >> r.real >> r.im;
}
```

### Предефиниране на оператори за равенство
Съобразно и с капсулацията се избира дали те биват дефинирани като приятели, т.к. се достъпват една по една членовете на класа, а те не биват дефинирани като член-функции.

```c++
friend bool operator==(const Complex& lhs, const Complex& rhs){
	return (lhs.real==rhs.real && lhs.im==rhs.im);
}
```
и съответно при дефиниран такъв оператор винаги дефинираме и **operator!=**
```c++
friend bool operator!=(const Complex& lhs, const Complex& rhs){
	return !(lhs==rhs);
}
```
Принципите за дизайн на този оператор са следните
- Ако класът притежава операция за проверка за еквивалентност на два обекта, то тя бива дефинирана чрез **operator==**.
- Ако класът дефинира **operator==**, то той еднозначно трябва да проверява дали двата обекта са еквивалентни!
 - Той трябва да е транзитивен, т.е. ако ```a==b``` и ```b==c``` са true, то ```a==c``` е true;
 - Ако един клас дефинира **operator==**, то той трябва да дефинира и **operator!=**. Потребителите очакват и двете функционалности;
 - Имплементацията на един от двата оператори трябва да бъде включена в другия, т.е. не е необходимо да се дефинират независимо един от друг;

## Задачи

**Задача 1:**
Реализирайте клас **Nvector**, който ще се използва за работа с математически вектор.
Предефинирайте оператори със следната функционалност:
 - Събиране на вектори.
 - Изваждане на вектори.
 - Умножение на вектор със скалар.
 - Проверка дали два вектора са успоредни.
 - Проверка дали два вектора са перпендикулярни.
 - Взимане на дължина на вектор.
 - Достъп до произволен елемент на вектор.
 - Вход и изход от потоци.

 ```c++
int main() {
	Nvector v(4);
	cin >> v;

	Nvector v2(4);
	cin >> v;

	Nvector result = v + v2;

	cout << result << endl;
      
}
 ```
 Релизирайте клас двумерната декартова координатна система, която приема 2 вектора, които са нейният базис.
 Реализрайте следните функции:
 - Връща вектор в базиса по подадени 2 координата.
 - По подаден вектор връща координатите му в базиса.
 
 ```c++
int main() {
	Nvector v(2);
	v[0] = 2;
	v[1] = 1;
	
	Nvector v2(2);
	v2[0] = 3;
	v2[1] = 1;
	
	twoDimCoordSystem s(v1, v2);
	
	cout << s1.getVectorByCoordinates(7, 4); // [26, 11]

	cout << s1.getCoordinatesByVector(7, 4); // [5, -1]

	cout << result << endl;
      
}
 ```
 
**Задача 2:**
Реализирайте клас **ComplexNumber**, който ще се използва за работа с комплексни числа.
Предефинирайте оператори със следната функционалност:
 - Събиране на комплексни числа.
 - Изваждане на комплексни числа.
 - Умножение на комплексни числа.
 - Деление на комплексни числа
 - Вход и изход от потоци.

```c++
int main()
{
	ComplexNumber c;
	cin >> c;

	ComplexNumber c2;
	cin >> c2;

	ComplexNumber result = c2 / c;

	cout << result << endl;
}
```
